/**************************************************************************
 This is an example for our Monochrome OLEDs based on SSD1306 drivers

 Pick one up today in the adafruit shop!
 ------> http://www.adafruit.com/category/63_98

 This example is for a 128x32 pixel display using I2C to communicate
 3 pins are required to interface (two I2C and one reset).

 Adafruit invests time and resources providing this open
 source code, please support Adafruit and open-source
 hardware by purchasing products from Adafruit!

 Written by Limor Fried/Ladyada for Adafruit Industries,
 with contributions from the open source community.
 BSD license, check license.txt for more information
 All text above, and the splash screen below must be
 included in any redistribution.
 **************************************************************************/

#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_NeoPixel.h>
#include <WiFi.h>
#include <WiFiClient.h>
#include <WebServer.h>
#include <ESPmDNS.h>
#include <WiFiUdp.h>
#include <ArduinoOTA.h>
#include <esp_int_wdt.h>
#include <esp_task_wdt.h>
#include <esp_wifi.h>
#include <esp_bt.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 32 // OLED display height, in pixels
#define PIN        15 // 
#define NUMPIXELS 1 // Popular NeoPixel ring size
#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32,

TwoWire I2C_1 = TwoWire(0); 
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &I2C_1, OLED_RESET);
Adafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);

#define NUMFLAKES     10 // Number of snowflakes in the animation example

#define LOGO_HEIGHT   16
#define LOGO_WIDTH    16

#define LOGO2_HEIGHT   32
#define LOGO2_WIDTH    128

// 'theSchaetzler_scale_bot', 128x32px
const unsigned char epd_bitmap_theSchaetzler_scale_bot [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x66, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x66, 0x06, 0x00, 0x3f, 0xc0, 0x00, 0x60, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xe0, 0x66, 0x06, 0x00, 0xe6, 0x70, 0x00, 0xf0, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xe6, 0x7f, 0xe7, 0xff, 0xff, 0xc6, 0x3f, 0xff, 0xff, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xc6, 0x3f, 0xe7, 0xff, 0xff, 0x86, 0x1f, 0xff, 0xff, 
	0x00, 0x18, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x06, 0x00, 0x66, 0x06, 0x00, 0x06, 0x00, 0x00, 0xf0, 
	0x04, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x06, 0x00, 0x66, 0x06, 0x00, 0x06, 0x00, 0x00, 0x60, 
	0x0c, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x06, 0x00, 0x66, 0x06, 0x00, 0x06, 0x00, 0x03, 0xfc, 
	0x0c, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06, 0x00, 0x06, 0x00, 0x03, 0xfc, 
	0x0c, 0x1b, 0xc0, 0x7c, 0x18, 0x00, 0x0f, 0x06, 0xf0, 0x3f, 0x06, 0x3f, 0xe6, 0x0f, 0x03, 0x44, 
	0x1f, 0x1f, 0xe0, 0xee, 0x1e, 0x00, 0x1d, 0xc7, 0xf8, 0x77, 0x86, 0x3f, 0xc6, 0x3d, 0xc3, 0x04, 
	0x1f, 0x1c, 0x71, 0x83, 0x0f, 0xe0, 0x30, 0xc7, 0x1c, 0xc1, 0x86, 0x01, 0xc6, 0x30, 0xc3, 0x3c, 
	0x0c, 0x18, 0x31, 0x83, 0x03, 0xfc, 0x30, 0x46, 0x0c, 0xc1, 0x86, 0x01, 0x86, 0x60, 0x63, 0x3c, 
	0x0c, 0x18, 0x31, 0x83, 0x00, 0x3e, 0x60, 0x06, 0x0c, 0x07, 0x86, 0x03, 0x06, 0x60, 0x63, 0x3c, 
	0x0c, 0x18, 0x31, 0xff, 0x00, 0x06, 0x60, 0x06, 0x0c, 0x7f, 0x86, 0x06, 0x06, 0x7f, 0xe3, 0x3c, 
	0x0c, 0x18, 0x31, 0x00, 0x00, 0x07, 0x60, 0x06, 0x0c, 0xe1, 0x86, 0x0c, 0x06, 0x60, 0x03, 0x3c, 
	0x0c, 0x18, 0x31, 0x83, 0x00, 0x03, 0x30, 0x66, 0x0c, 0xc1, 0x86, 0x18, 0x06, 0x60, 0x63, 0x3c, 
	0x0c, 0x18, 0x31, 0x83, 0x00, 0x03, 0x30, 0xc6, 0x0c, 0xc1, 0x86, 0x38, 0x06, 0x30, 0xc3, 0xfc, 
	0x0c, 0x18, 0x30, 0xee, 0x00, 0x06, 0x1d, 0xc6, 0x0c, 0xe7, 0x87, 0xbf, 0xe6, 0x3d, 0xc3, 0xfc, 
	0x0c, 0x18, 0x30, 0x7c, 0x00, 0x0e, 0x0f, 0x06, 0x0c, 0x7c, 0xc3, 0xbf, 0xe6, 0x0f, 0x00, 0x60, 
	0x0c, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 
	0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf1, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x01, 0x00, 0x40, 0x10, 0x04, 0x01, 0x00, 0x40, 0x10, 0x04, 0x01, 0x00, 0x40, 0x10, 0x04, 0x01, 
	0x01, 0x00, 0x40, 0x10, 0x04, 0x01, 0x00, 0x40, 0x10, 0x04, 0x01, 0x00, 0x40, 0x10, 0x04, 0x01, 
	0x01, 0x00, 0x40, 0x10, 0x04, 0x01, 0x00, 0x40, 0x10, 0x04, 0x01, 0x00, 0x40, 0x10, 0x04, 0x01, 
	0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
	0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
	0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

int i;
int sign;
long value;
float result;
float VoltageBattery;
unsigned long tempmicros;
unsigned long ipmillis;
bool wlan_on = true;
#define ledPin 47
#define clockpin 2
#define datapin 4
#define VCC_DISPLAY 17
#define WLAN true
#define Button 0


void setup() {
  Serial.begin(115200);
  I2C_1.begin(11, 12);
  pixels.begin(); // INITIALIZE NeoPixel strip object (REQUIRED)

  pinMode(clockpin, INPUT_PULLUP);
  pinMode(datapin, INPUT_PULLUP);
  pinMode(ledPin, OUTPUT);
  pinMode(VCC_DISPLAY,OUTPUT);
  digitalWrite(VCC_DISPLAY, HIGH);
  delay(500);
  digitalWrite(ledPin, LOW);
  pinMode(Button, INPUT_PULLUP);
  
  float Voltage = 1.5;
  analogWrite(21,(int)(Voltage*255/3.24));
  //float DisplayVoltage = 2.0;
  //analogWrite(VCC_DISPLAY,(int)(DisplayVoltage*255/3.24));
  delay(500);

  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }

  // Show initial display buffer contents on the screen --
  // the library initializes this with an Adafruit splash screen.
  
  display.clearDisplay();
  display.drawBitmap(0,0,epd_bitmap_theSchaetzler_scale_bot,128,32,1);
  display.setTextSize(1); // Draw 2X-scale text
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(45, 25);
  display.display();
  delay(5000);
  wlan_on = digitalRead(Button);
}

void loop() {    
  float SupplyCalip = analogRead(10)/4096.0*3.3;
  VoltageBattery = analogRead(9)*2.0/4096.0*3.3;
  int not_sampled = 1;
  while(not_sampled){
    tempmicros=micros();
    while ((digitalRead(clockpin)==HIGH)) {}
    //if clock is LOW wait until it turns to HIGH
    tempmicros=micros();
    while ((digitalRead(clockpin)==LOW)) {} //wait for the end of the HIGH pulse
    if ((micros()-tempmicros)>500) { //if the HIGH pulse was longer than 500 micros we are at the start of a new bit sequence
      decode(); //decode the bit sequence
      not_sampled = 0;
    }
  }
  ipmillis=millis();
  pixels.setPixelColor(0, pixels.Color(0, 0, 0));
  pixels.show();   // Send the updated pixel colors to the hardware.
  display.clearDisplay();
  display.setTextSize(1); // Draw 2X-scale text
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  display.print("CLP:");
  display.print(SupplyCalip);
  display.print(" BAT:");
  display.println(VoltageBattery);
  display.setTextSize(2); // Draw 2X-scale text
  display.print(result);
  display.println("mm");
  display.display();
}

void decode() {

  sign=1;
  value=0;
  for (i=0;i<23;i++) {
    //esp_sleep_enable_ext1_wakeup(GPIO_NUM_12,HIGH) 
    //immer nur Aufwachen wenn GPIO_NUM_12 High ist while 
    //(digitalRead(clockpin)==LOW) {esp_light_sleep_start() 
    //print "ESP GEHT SCHLAFEN"} while (digitalRead(clockpin)==HIGH) { 
    //Automatisch wach und hier Werte messen (durch "esp_sleep_enable_ext1_wakeup" }
    while (digitalRead(clockpin)==HIGH) {} //wait until clock returns to HIGH- the first bit is not needed
    while (digitalRead(clockpin)==LOW) {} //wait until clock returns to LOW
    if (digitalRead(datapin)==LOW) {
      if (i<20) {
        value|= 1<<i;
      }
      if (i==20) {
        sign=-1;
      }
    }
  }
  result=(value*sign)/100.00;    
}